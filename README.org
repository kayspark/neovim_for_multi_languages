* A neovim configuration for multiple languages

This configuration is referring  LazyVim and referred dotfiles from Josh medesky, from time to time.

For those who is using multiple languages, neovim can be a good choice.
  This repository is for my workflow like below :
  - SQL with oracle database : vim-dadbod for query execution and completion
  - Java and C++ legacy projects
  - zsh/fish/xml/html for rutine works
  - Exciting experiment projects with Rust, Json and typescripts.

Installation instruction is same as LazyVim. Start with starter kit and add your preferred plugins by copying. lua/plugins/lsp directory can be ignored but I copied it due to reference and test purposes. Codes are not cleaned up yet but it will be keep updated weekly basis.

* multiple languages?
Key binding matters for non english users like me. for example,Ctrl+space for me means changing input languages. Howver many plugins are using it with other purposes.
In language servers, key binding for code actions also mattered but seems not cared carefully yet. So, I started to make this repository to share my experiments, someday can be a common practice hopefully.



* work in process
- rust and json for backend development with neovim
- vim-dadbod for database

* Recent Changes
** 2026-02-17
 - Git UI policy tightened to Neogit-first workflow.
 - Disabled default LazyGit key bindings from LazyVim Snacks (`<leader>gg`, `<leader>gG`) to avoid confusion.
 - Removed `ai.claudecode` extra (CLI workflow is primary).
 - Commented out language extras for easy later enable:
   - `lazyvim.plugins.extras.lang.rust`
   - `lazyvim.plugins.extras.lang.typescript`
   - `lazyvim.plugins.extras.lang.yaml`
 - Re-enable by uncommenting entries in `lua/config/lazy.lua`, then run `:Lazy sync`.

** 2026-02-06
 - Removed `sqls` integration from `lua/plugins/lsp.lua` and `neoconf.json`.
 - SQL workflow now uses `vim-dadbod` and `vim-dadbod-completion` only.
 - Added a Git signing runbook for contributors and agents: `docs/ops/git-signing.md`.

** 2026-02-02
 - **Configuration Health Check & Cleanup**:
   - Reviewed and updated the configuration to align with the latest LazyVim standards.
   - Cleaned up `lua/plugins/database.lua` to remove redundant settings.
 - **LazyVim Extras Update**:
   - The configuration now uses `aerial` instead of the deprecated `navic` for the symbols outline. It's recommended to remove the `navic` extra via the `:LazyExtras` command to avoid conflicts.

* key maps
This list includes all custom key maps defined in this repository. Default LazyVim key maps are not listed.

** general
| Mode | Key        | Action                              |
|------+------------+-------------------------------------|
| n    | <leader>bj | Next buffer                         |
| n    | <leader>bk | Previous buffer                     |
| n    | <leader>bn | Next buffer                         |
| n    | <leader>bp | Previous buffer                     |
| n    | <leader>bb | Telescope buffers (MRU/last used)   |
| v    | <leader>y  | Yank selection to system clipboard  |
| n    | <leader>]  | Run :Gen                            |
| v    | <leader>]  | Run :Gen on selection               |
| v    | <C-s>      | Sort selected lines                 |
| v    | <leader>rr | Replace selected text in whole file |
| v    | J          | Move selected line(s) down          |
| v    | K          | Move selected line(s) up            |

** git
Neogit is the primary Git UI in this config. LazyGit integration is intentionally disabled.

| Mode | Key        | Action                 |
|------+------------+------------------------|
| n    | <leader>gg | Neogit status          |
| n    | <leader>gc | Neogit commit          |
| n    | <leader>gd | Diffview open          |
| n    | <leader>gD | Diffview close         |
| n    | ]g         | Next git hunk          |
| n    | [g         | Previous git hunk      |
| n    | gs         | Stage hunk             |
| n    | gS         | Stage buffer           |
| n    | gx         | Reset hunk             |
| n    | gX         | Reset buffer           |
| n    | gu         | Undo stage hunk        |
| n    | gh         | Preview hunk           |
| n    | gb         | Stage buffer           |

*** Git workflow (Neogit + Diffview)
This is the recommended day-to-day flow in this config.

**** 1) Add / stage changes
- Open Neogit status: ~<leader>gg~
- Stage from Neogit status buffer (Magit-style) for file/hunk selection.
- Or stage directly from code with gitsigns:
  - ~gs~ stage hunk
  - ~gS~ stage buffer
  - ~gh~ preview hunk before staging

**** 2) Commit
- Open commit flow: ~<leader>gc~
- Write commit message in the commit buffer.
- Save and confirm commit from Neogit.
- If commit signing is required, follow ~docs/ops/git-signing.md~.

**** 3) Fetch / pull / rebase
- Open Neogit: ~<leader>gg~
- Use Neogit popups to run fetch/pull/rebase operations.
- Tip: use ~?~ inside Neogit to see current buffer actions.

**** 4) Review diff before merge
- Open repository diff view: ~<leader>gd~ (DiffviewOpen)
- Close diff view: ~<leader>gD~ (DiffviewClose)
- Useful commands in command line:
  - ~:DiffviewFileHistory~ for file/repo history diff
  - ~:DiffviewToggleFiles~ to show/hide file panel
  - ~:DiffviewRefresh~ after branch updates

**** 5) Merge with diff
- Fetch and checkout target branch in Neogit.
- Open ~<leader>gd~ and review changed files before merge.
- Run merge from Neogit popup.
- If conflicts occur:
  - Use Diffview to inspect both sides and conflict locations.
  - Resolve in buffers, stage resolved files, then complete merge commit.

**** 6) Push
- Open Neogit: ~<leader>gg~
- Use push popup/action to push current branch.
- Prefer pushing only after diff review and clean status.

**** Quick habits
- Before commit: ~gh~ on important hunks + ~<leader>gd~ full diff pass.
- Before push: confirm no unstaged/untracked surprises in Neogit status.
- For history investigation: ~:DiffviewFileHistory %~ on current file.

** tmux navigator
| Mode | Key    | Action                      |
|------+--------+-----------------------------|
| n    | <C-h>  | TmuxNavigateLeft            |
| n    | <C-j>  | TmuxNavigateDown            |
| n    | <C-k>  | TmuxNavigateUp              |
| n    | <C-l>  | TmuxNavigateRight           |
| n    | <C-\>  | TmuxNavigatePrevious        |

** spell checking
Spell checking is disabled globally and enabled for prose filetypes (markdown, text, gitcommit, org).
Korean (Hangul) and other CJK characters are skipped via ~spelllang = { "en", "cjk" }~.
Personal dictionary is stored in ~spell/en.utf-8.add~.

| Mode | Key | Action                          |
|------+-----+---------------------------------|
| n    | zg  | Add word to personal dictionary |
| n    | zw  | Mark word as wrong              |
| n    | zug | Undo zg (remove good word)      |
| n    | ]s  | Jump to next misspelled word    |
| n    | [s  | Jump to previous misspelled     |
| n    | z=  | Show spelling suggestions       |

** Java (jdtls)
jdtls (Eclipse JDT Language Server) is configured via =ftplugin/java.lua=, not through the standard mason-lspconfig auto-attach.
This is the nvim-jdtls recommended approach because jdtls needs per-project workspace isolation and =start_or_attach()= semantics.

| Mode | Key        | Action                |
|------+------------+-----------------------|
| n    | <leader>jd | Debug test class      |
| n    | <leader>jm | Debug test method     |
| n    | <leader>jr | Organize imports      |

*** JDK version layering (real-world example: YTAP project)
This config handles projects where production targets JDK 6/8 but jdtls itself requires JDK 21+.
Three JDK roles must be separated:

| Role                  | JDK   | Why                                                  |
|-----------------------+-------+------------------------------------------------------|
| jdtls runtime         | 22    | jdtls 1.40+ requires JDK 21 minimum                 |
| Gradle daemon         | 8     | Gradle 7.6.x supports up to JDK 19; project needs 8 |
| Project compile target | 6/8  | Production equipment PCs run JDK 6/8                 |

**** How it works
1. *jdtls process* runs on JDK 22 via =~/.config/bin/jdtls-java= wrapper.
   The wrapper checks jenv first, then falls back through JDK 25/24/.../21 paths.
   Must return JDK >= 21 or jdtls refuses to start.

2. *Gradle import* uses JDK 8 via =java.import.gradle.java.home= setting.
   Without this, jdtls spawns the Gradle daemon with its own JDK (22),
   which Gradle 7.6.4 doesn't support — the import silently fails and
   no classes resolve.

3. *Compilation target* is set by =sourceCompatibility= / =targetCompatibility=
   in =build.gradle= (e.g., ='1.6'=). jdtls reads this from Gradle metadata.
   The =configuration.runtimes= list with =default = true= on =JavaSE-1.8=
   tells jdtls which JDK to use for type resolution.

**** jenv integration
=jenv= global is set to =1.8= (matching the project). The =jdtls-java= wrapper
explicitly bypasses jenv when it returns JDK < 17, falling back to higher JDKs.
This means =jenv= controls your shell/Gradle JDK while jdtls gets its own.

**** Multi-module Gradle root detection
For multi-module Gradle projects, =find_root= must find the *parent* root,
not a child subproject's =build.gradle=. Consider this layout:
#+begin_example
my-project/            <- parent (has settings.gradle, gradlew, .git)
  settings.gradle
  gradlew
  build.gradle
  lib/
  common/              <- child module
    build.gradle
    src/
  module-a/            <- child module
    build.gradle
    src/
  module-b/            <- child module
    build.gradle
    src/
#+end_example

When you open =module-a/src/Foo.java=, =find_root= walks upward.
If =build.gradle= is in the marker list, it matches =module-a/build.gradle= first
and jdtls only imports that single module — cross-module classes won't resolve.

The fix is to split markers into two priority tiers:
#+begin_src lua
-- Tier 1: top-level markers (finds my-project/, not module-a/)
find_root({ "settings.gradle", "settings.gradle.kts", "gradlew", "mvnw", ".git" })
-- Tier 2: fallback for standalone single-module projects
find_root({ "build.gradle", "build.gradle.kts", "pom.xml" })
#+end_src
Tier 1 skips past child =build.gradle= files and lands on the parent where
=settings.gradle= lives. jdtls then imports the entire multi-module project
with all submodule dependencies resolved.

**** Troubleshooting
- =:LspInfo= — check jdtls is attached and shows the correct root dir.
- =:LspLog= — look for Gradle import errors or JDK version complaints.
- Workspace cache at =~/.cache/nvim/jdtls-workspaces/<project>/= — delete to force reimport.
- If classes don't resolve after import, check =:LspLog= for
  ="jdtls requires at least Java 21"= (jdtls-java wrapper issue) or
  Gradle daemon failures (JDK mismatch).

** orgmode text objects
| Mode | Key | Action                     |
|------+-----+----------------------------|
| o/x  | ic  | Inner heading              |
| o/x  | ac  | Around heading             |
| o/x  | is  | Inner subtree              |
| o/x  | as  | Around subtree             |
| o/x  | iC  | Inner heading from root    |
| o/x  | aC  | Around heading from root   |
| o/x  | iS  | Inner subtree from root    |
| o/x  | aS  | Around subtree from root   |

* references

- Tim Pope's vim-dadbod
- Git signing runbook: `docs/ops/git-signing.md`
 - [[https://github.com/joshmedeski/dotfiles.git][Josh medesky's dot files]]
 - LazyVim starter Kit
